---
title: "Go の標準ライブラリでプログレスバーを作る！〜ターミナルに色が描画される仕組み〜"
emoji: "😽"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["tui", "Go"]
published: true
---

# はじめに

皆さんは普段開発している中で、様々な CLI ツールを使われていると思います。例えば、`git status` で表示される色付きの差分、`npm install` で表示されるプログレスバー、`curl` のダウンロード進捗など、ターミナル上で動的に更新される UI やカラフルな表示を目にすることがあるのではないでしょうか。

「こういうの、どうやって実装しているんだろう？」と気になったことはありませんか？

実は、これらの多くは**ANSI エスケープシーケンス**という特殊な文字列を使って実現されています。そして、Go の標準ライブラリだけでも、外部パッケージに頼ることなく、カラフルでインタラクティブなターミナル UI を作ることができます。

本記事では、ターミナルに色が描画される仕組みについて解説してから、Go の標準ライブラリのみを使ってプログレスバーを実装します。

# ANSI エスケープシーケンスとは？

ANSI エスケープシーケンスは、ターミナル（端末エミュレータ）に対して「文字の色を変えて」「カーソルを表示/非表示にして」といった指示を送るための特殊な文字列です。

1970年代に ANSI（米国規格協会）によって標準化されたもので、現在でも多くのターミナルでサポートされています。

## 基本構文

ANSI エスケープシーケンスは、以下の形式で記述します：

```
ESC [ パラメータ コマンド
```

- **ESC**：エスケープ文字（ASCII コード `0x1B` または `\x1b`、`\033`、`\e`）
- **[**：CSI（Control Sequence Introducer）の開始を示す
- **パラメータ**：数値や記号（セミコロンで区切って複数指定可能）
- **コマンド**：実行する操作を示すアルファベット

例えば、背景色を緑にするには `\x1b[42m` というエスケープシーケンスを使います。

## 今回使用するエスケープシーケンス

プログレスバーを実装するために、以下のエスケープシーケンスを使用します：

| エスケープシーケンス | 説明 |
|---|---|
| `\x1b[?25l` | カーソルを非表示にする |
| `\x1b[?25h` | カーソルを表示する |
| `\r` | 行頭に戻る（キャリッジリターン） |
| `\n` | 改行（ラインフィード） |
| `\x1b[42m` | 背景を緑にする |
| `\x1b[0m` | すべてのスタイルをリセット |

### それぞれの役割

**カーソルの表示制御（`\x1b[?25l` / `\x1b[?25h`）**
プログレスバーを表示している間、点滅するカーソルが表示されると見た目が悪くなります。そこで、描画中はカーソルを非表示にし、完了後に再表示します。

**行頭への移動（`\r`）**
`\r` は厳密にはANSIエスケープシーケンスではなく、キャリッジリターンという制御文字です。これを使うことで、同じ行に何度も上書きして表示できます。

**改行（`\n`）**
`\n` はラインフィードという制御文字で、カーソルを次の行に移動させます。

**色設定（`\x1b[42m` / `\x1b[0m`）**
`\x1b[42m` で背景色を緑に設定し、プログレスバーの進行部分を視覚的に表現します。`\x1b[0m` はすべてのスタイル（色、太字など）をデフォルトに戻すためのシーケンスで、これを使わないと以降の出力も緑の背景になってしまいます。

## Go で試してみる

実際に Go でこれらのエスケープシーケンスを使ってみましょう。

```go:main.go
package main

import "fmt"

const (
    CursorHide  = "\x1b[?25l"
    CursorShow  = "\x1b[?25h"
    BgGreen     = "\x1b[42m"
    BgReset     = "\x1b[0m"
)

func main() {
    // カーソルを非表示にして、背景色を緑にしたテキストを表示
    fmt.Print(CursorHide)
    fmt.Println(BgGreen + "これは緑の背景です" + BgReset)
    fmt.Print(CursorShow)
}
```

このコードを実行すると、カーソルが一時的に非表示になり、緑の背景を持つテキストが表示された後、カーソルが再表示されます。

# プログレスバーの実装

それでは、これまで学んだエスケープシーケンスを使って、実際にプログレスバーを実装してみましょう。

## 実装方針

プログレスバーの実装は以下の考え方で行います：

1. **カーソルを非表示にする** - プログレスバー表示中に点滅するカーソルが見えないようにする
2. **進捗に応じて緑の背景を持つスペースを描画** - 進捗部分は `BgGreen` で背景を緑にしたスペースで表現
3. **未完了部分は通常のスペース** - `BgReset` でスタイルをリセットしてから通常のスペースを描画
4. **`\r` で行頭に戻って上書き** - 毎回行頭に戻ることで、同じ行に何度も描画して動的に更新
5. **完了後にカーソルを再表示** - `defer` を使って必ず最後にカーソルを表示

ポイントは、**背景色を設定したスペースを並べることで、視覚的なバーを表現する**ことです。

## 完全なコード

```go:main.go
package main

import (
	"fmt"
	"strings"
	"time"
)

const (
	// カーソル制御
	CursorHide  = "\x1b[?25l"
	CursorShow  = "\x1b[?25h"
	ReturnStart = "\r"

	// 色設定
	BgGreen = "\x1b[42m" // 背景を緑にする
	BgReset = "\x1b[0m"  // 色設定（背景・文字）をリセット
)

func main() {
	total := 50 // バーの長さ（スペースの個数）

	fmt.Print(CursorHide)
	defer fmt.Print(CursorShow)

	for i := 0; i <= 100; i++ {
		percent := i
		filledLen := (total * percent) / 100

		// 1. 進捗部分は「背景緑」＋「スペース」
		// 背景色が緑になっているので、ただの空白が「緑のブロック」に見える
		filled := BgGreen + strings.Repeat(" ", filledLen)

		// 2. 未完了部分は「リセット（デフォルト背景）」＋「スペース」
		// ここは何も色がついていないただの空白になる
		empty := BgReset + strings.Repeat(" ", total-filledLen)

		// 3. 描画
		// \r で戻る -> 緑の空白 -> 普通の空白 -> 数字
		fmt.Printf("%s%s%s %d%%", ReturnStart, filled, empty, percent)

		time.Sleep(50 * time.Millisecond)
	}

	fmt.Print("\nDone!\n")
}
```
途中経過はこんな感じになると思います。
![progress bar](/images/progressBar.png)
## なぜ最後に `\n` が必要なのか？

コードの最後で `fmt.Print("\nDone!\n")` としていますが、もし最後の `\n` を省略して `fmt.Print("\nDone!")` とすると、zsh などのシェルでは行末に反転表示の **`%` 記号**が表示されることがあります。
これには、以下のような理由があります。
多くのシェル（特に zsh）は、プログラムの出力が改行で終わっていない場合、以下のような動作をします：

1. プログラムが改行なしで終了
2. シェルは「出力が改行で終わっていない」ことを検知
3. 視覚的にわかりやすくするため、**反転表示の `%` 記号**を行末に表示
4. その後、シェルのプロンプト（`$` や `>` など）を新しい行に表示

これは「出力が途中で切れている可能性がある」ことをユーザーに知らせるための機能です。

つまり、この後の `\n` によって以下のことを実現しています。
- "Done!" を表示した後にもう一度改行することで、出力が改行で終わる
- シェルは「正常に改行で終わった」と判断し、`%` を表示しない

このように、CLI ツールを作る際は、最後の出力が改行で終わるように気をつけましょう。

# 最後に

本記事では、Go の標準ライブラリだけを使ってプログレスバーを実装しながら、ANSI エスケープシーケンスの仕組みを学びました。カーソル制御と背景色、そしてキャリッジリターンを組み合わせることで、シンプルなプログレスバーが作れることがわかりました。

もちろん、実際のプロダクション環境では、より高機能なライブラリを使うことも検討すべきです。例えば：

- **[bubbletea](https://github.com/charmbracelet/bubbletea)** - Go 向けの TUI フレームワーク
- **[lipgloss](https://github.com/charmbracelet/lipgloss)** - ターミナル向けのスタイリングライブラリ
- **[pterm](https://github.com/pterm/pterm)** - Go 向けのプログレスバーやスピナーライブラリ

「ターミナルに色が表示されるのはなぜ？」「プログレスバーはどうやって動いているの？」といった、ちょっとした疑問を深掘りしてみると、意外と面白い仕組みが見えてきます。こういった好奇心を大切にすると、技術への理解がより深まりますね。
